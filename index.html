<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Assignment 1</title>
    <style>
        body {
            margin: 100px;
        }

        .container-div {
            /* div center*/
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .subdivision-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #container0,
        #container1 {
            width: 50%;
        }
    </style>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.147.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.147.0/examples/jsm/"
          }
        }
    </script>
</head>

<body>
    <h1 style="text-align: center;">Assignment 1: Surface Mesh Simplication and Subdivision</h1>
    <!-- <h2>Introduction</h2>
    <p>For this assignment, you will be implementing two algorithms covering: 1. Loop Subdivision 2. Quadratic Error
        Mesh Decimation over any 3D object.
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Subdivision_surface#Loop_subdivision_surface">Loop Subdivision</a>
        </li>
        <li><a href="https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf">Quadric Error Mesh Decimation</a></li>
    </ul>
    We have made available a visualization tool using the Three.js library implemented in "./js/assignment1.js" and an
    example implementation located in "./assignments/assignment1.py". Your objective is to create implementations for
    both "subdivision_loop" and "simplify_quadric_error". You are encouraged to use a programming language with which
    you are comfortable. The output results should be in the obj format, and you must visualize your outcomes
    accordingly.
    <br><br>
    <b>How to Submit: </b>Please submit this template file along with your implementation as a zip file. The zip file
    should contain your source code, the generated results in OBJ mesh format, and a report that has been modified using
    this HTML file. The report should comprise your results and a concise explanation of your implementation.
    Alternatively, you may choose to create a GitHub repository containing all these elements and provide a link for
    submission.
    <br><br>
    <b>Grading: </b>The grading is based on the correctness of your implementation. You are encouraged to use the
    visualization tool to debug your implementation. You can also use the visualization tool to test your implementation
    on other 3D models. You can find an example of 3D model in the "./assets" folder.</p>
    </p> -->
    <h2>Background</h2>
    <section>
        <p>In the realm of 3D vision, the geometric manipulation of mesh models is fundamental for various applications,
            including computer graphics, animation, and virtual reality. Two pivotal techniques in mesh processing are
            Loop
            subdivision for mesh refinement and Quadric Error Metrics (QEM) for mesh simplification.</p>

        <p><strong>Loop Subdivision</strong> is a method that iteratively refines a mesh by splitting edges and creating
            smoother surfaces. This technique is rooted in the work of Charles Loop and is widely used for generating
            higher
            resolution meshes from coarse geometric data. It is particularly favored for its ability to produce smooth,
            visually appealing surfaces without altering the original mesh's topology.</p>

        <p><strong>Quadric Error Metrics (QEM)</strong>, on the other hand, is a simplification strategy that reduces
            the
            complexity of a mesh while attempting to minimize the geometric error. This approach calculates an error
            metric
            for each potential edge collapse, allowing the algorithm to prioritize changes that have the least impact on
            the
            mesh's apparent shape. It is highly valued for its ability to create Level of Detail (LOD) models essential
            for
            real-time rendering and large-scale visualizations.</p>

        <h2>Implementation Details</h2>
        <p>For the <strong>Loop subdivision</strong>, the implementation leverages the <code>trimesh</code> library,
            which
            provides robust tools for mesh analysis and manipulation. The library's functionality facilitates the
            subdivision process, enabling seamless refinement of mesh models.</p>

        <p>In contrast, the <strong>QEM</strong> implementation is realized through a bespoke data structure designed to
            manage complex mesh relationships efficiently. This custom structure facilitates the dynamic calculation of
            error metrics and the subsequent prioritization of edge collapses, ensuring the mesh simplification is both
            efficient and effective.</p>

        <p>These techniques showcase the synergy between established algorithms and custom data structures in the field
            of
            3D vision, providing a comprehensive toolkit for the detailed and optimized rendering of three-dimensional
            models.</p>
    </section>

    <h2>Data Structure</h2>
    <p>The data structures involved are:</p>
    <ul>
        <li><strong>Vertices</strong>: A NumPy array of vertex positions in 3D space.</li>
        <li><strong>Faces</strong>: A NumPy array that defines the vertices of each triangular face.</li>
        <li><strong>Edges</strong>: A NumPy array that lists the vertex pairs that make up the mesh edges.</li>
        <li><strong>Unique, Inverse</strong>: Arrays used to identify unique edges and their mapping.</li>
        <li><strong>Edge_inter, edge_bound</strong>: Arrays that store indices for interior and boundary edges.</li>
    </ul>
    <h3>For loop subdivision: Trimesh</h3>
    <section>
        <h3>Custom Data Structure for QEM</h3>
        <p>The implementation of the Quadric Error Metrics (QEM) algorithm for mesh simplification necessitates a
            sophisticated data structure that can efficiently manage the complex relationships and operations required.
            This
            custom structure, as designed in the provided code, supports the following functionalities:</p>

        <ul>
            <li><strong>Mesh Loading:</strong> Reads mesh data from an OBJ file, extracting vertices and faces to form
                the
                initial mesh structure.</li>
            <li><strong>Edge Construction:</strong> Builds an edge data structure that maps vertices to edges and vice
                versa, which is critical for identifying edge collapses during simplification.</li>
            <li><strong>Normal and Center Calculation:</strong> Computes face normals and centers, which are necessary
                to
                establish the error metrics for each vertex.</li>
            <li><strong>Vertex Normal Computation:</strong> Determines vertex normals by averaging the normals of
                adjacent
                faces, a step that requires efficient sparse matrix operations.</li>
            <li><strong>Adjacency Mapping:</strong> Establishes a bidirectional mapping of vertex adjacency, allowing
                the
                algorithm to quickly access neighboring vertices and faces.</li>
            <li><strong>Laplacian Matrix:</strong> Constructs the Laplacian matrix representing the mesh connectivity,
                facilitating various geometric processing operations.</li>
            <li><strong>QEM Execution:</strong> Runs the edge collapse operations based on the computed error metrics,
                progressively simplifying the mesh while aiming to minimize geometric errors.</li>
            <li><strong>Mesh Reconstruction:</strong> After simplification, the mesh is rebuilt to reflect the new
                topology,
                which includes updating vertices and faces as well as recalculating normals and adjacency information.
            </li>
        </ul>

        <p>This custom data structure is integral to the QEM algorithm, enabling the efficient and accurate execution of
            mesh simplification. It allows for the dynamic update of mesh properties and relationships, ensuring the
            resulting simplified mesh maintains a high fidelity to the original geometry.</p>
    </section>

    <p>
    <section>
        <h2>Mesh Processing Techniques - Desgin Logic</h2>
        <p>The Loop subdivision and Quadric Error Metrics (QEM) are two distinct mesh processing techniques utilized to
            modify mesh complexity and detail.</p>

        <p>For the <strong>Loop subdivision</strong>, the <code>trimesh</code> library was employed. This library
            provides a
            convenient and efficient way to handle and visualize the complex operations involved in subdividing a mesh.
            It
            automates the process of adding vertices and faces, thus smoothing and refining the mesh with each
            iteration.
        </p>

        <p>Conversely, the <strong>QEM algorithm</strong> was implemented through a custom data structure tailored to
            the
            specific needs of mesh decimation. This structure manages the complex relationships and transformations
            required
            by the QEM process, such as edge collapses and vertex adjustments, ensuring that the resultant mesh
            accurately
            simplifies the original form while preserving as much detail as necessary.</p>

        <p>The combination of <code>trimesh</code> for Loop subdivision and a bespoke structure for QEM demonstrates a
            robust approach to mesh manipulation, catering to both refinement and simplification tasks within
            computational
            geometry.</p>
    </section>

    <br><br>
    </p>
    <h2>Loop Subdivision</h2>
    <section>
        <h3>Algorithm</h3>
        <p>The Loop subdivision algorithm refines meshes by subdividing their faces to create smoother surfaces. It is
            named
            after Charles Loop, who introduced it in his master's thesis. The algorithm is based on a set of rules for
            generating new vertices (odd vertices) and repositioning existing ones (even vertices).</p>

        <h3>Odd Vertices</h3>
        <p>New vertices are added at the midpoint of each edge. The position of an odd vertex is calculated using the
            adjacent vertices of the original mesh:</p>
        <p><em>Odd vertex position</em> = (3/8 &times; (Position of vertex 1 + Position of vertex 2)) + (1/8 &times;
            (Adjacent vertex 1 + Adjacent vertex 2))</p>

        <h3>Even Vertices</h3>
        <p>Existing vertices are adjusted based on their neighboring vertices. The new position of an even vertex is
            calculated as follows:</p>
        <p><em>Even vertex position</em> = (1 - n &times; β) &times; (Original vertex position) + β &times; Σ (Positions
            of
            adjacent vertices)</p>
        <p>where:</p>
        <ul>
            <li><em>n</em> = the number of adjacent vertices</li>
            <li><em>β</em> = 1/n &times; (5/8 - (3/8 + 1/4 &times; cos(2 &times; π / n))<sup>2</sup>)</li>
        </ul>

        <p>This iterative process of adding and adjusting vertices results in a smoother mesh that approximates a
            subdivision surface.</p>
    </section>
    <br><br>
    <section>
        <section>
            <h3>Implementation Details of Loop Subdivision</h3>
            <p>The Loop subdivision algorithm, as implemented here, leverages the <code>trimesh</code> library to refine
                the
                resolution of a mesh. This process iteratively increases the mesh's vertex and face count, yielding a
                smoother
                and more detailed surface. Below are the algorithm's implementation steps:</p>

            <ol>
                <li><strong>Geometry Preparation:</strong> The mesh geometry is initially prepared, distinguishing
                    between
                    interior and boundary edges. This step is essential for applying different subdivision rules for
                    boundary
                    and interior vertices.</li>
                <li><strong>Odd Vertices Calculation:</strong> New 'odd' vertices are introduced on each edge. For
                    interior
                    edges, these vertices are positioned according to a weighted average of the adjacent vertices. The
                    positions
                    are calculated using a 3/8 weight for the edge vertices and 1/8 for the vertices opposite the edge.
                    For
                    boundary edges, a simpler averaging of the edge vertices is used.</li>
                <li><strong>Even Vertices Adjustment:</strong> The original 'even' vertices are adjusted based on their
                    neighboring vertices. For vertices in the interior, a beta coefficient—dependent on the valence of
                    the
                    vertex—dictates the adjustment. Boundary vertices are adjusted using the average of their
                    neighboring
                    boundary vertices.</li>
                <li><strong>Mesh Reconstruction:</strong> The mesh is reconstructed with the new vertices. New faces are
                    formed
                    by connecting the new 'odd' vertices with the original 'even' vertices, resulting in a fourfold
                    increase in
                    the number of faces, thereby refining the mesh.</li>
                <li><strong>Boundary Conditions:</strong> The implementation accounts for boundary vertices to ensure
                    the mesh's
                    integrity at the edges post-subdivision. Special rules are applied to boundary vertices to maintain
                    the
                    shape and structure of the mesh.</li>
            </ol>

            <p>Utilizing the <code>trimesh</code> library facilitates the manipulation and visualization of mesh data
                structures
                throughout the subdivision process. After multiple iterations of the Loop subdivision algorithm, the
                mesh
                becomes an enhanced representation of the initial model, with improved smoothness and detail that more
                closely
                approximates the original form. The code provided illustrates a comprehensive application of Loop
                subdivision,
                including the handling of boundary conditions, enabling its use across various mesh topologies.</p>
        </section>


        <h3>Results </h3>
        <section>
            <p>The Loop Subdivision process was applied to a 3D mesh model to enhance its geometric detail over three
                iterations. This subdivision method smoothens and refines the mesh by increasing the number of vertices
                and
                faces, resulting in a more polished and high-resolution model.</p>

            <p>The following section represents the original object and the subdivided object. Initially, the mesh was
                characterized by a relatively coarse geometry, with a limited number of vertices and
                faces. The structure of the original mesh is evident in the blockier and less defined features. The
                first
                iteration of the Loop Subdivision algorithm recalculates vertex positions and subdivides each triangular
                face
                into four new triangles, increasing the vertex count and face count significantly.</p>

            <p>After three iterations, the transformation is substantial:</p>
            <ul>
                <li>The number of vertices increased from the original 2,503 to 159,142.</li>
                <li>The number of faces grew from 4,968 to 317,952.</li>
            </ul>

            <p>This exponential growth in complexity results in a smoother and more detailed surface topology, closely
                approximating the true curves and nuances of the model's form. The final mesh displays a refined surface
                with
                enhanced details, which are particularly noticeable in areas where the original model lacked definition.
                Such an
                increase in mesh resolution is beneficial for applications requiring high-quality visualizations, such
                as in
                computer graphics, animation, and 3D printing.</p>

            <p>It is important to note that while Loop Subdivision greatly improves the visual quality of a model, it
                also
                increases the computational complexity. Therefore, it should be applied considering the trade-off
                between
                detail
                and performance based on the intended use of the mesh.</p>
        </section>


        </p>
        <div class="subdivision-container">
            <div id="container0"></div>
            <div id="container1"></div>

        </div>
        <h2>Quadric Error Mesh Decimation</h2>
        <section>
            <h3>Algorithm</h3>
            <p>The Quadric Error Metrics (QEM) algorithm is a sophisticated technique used for mesh simplification. It
                reduces
                the complexity of a 3D mesh while striving to preserve the original shape and features as closely as
                possible.
                The algorithm achieves this by iteratively collapsing edges based on a calculated error metric that
                estimates
                the deviation from the original surface.</p>

            <h4>Quadric Error Calculation</h4>
            <p>The core of the QEM algorithm is the computation of the "quadric" error metric for each vertex in the
                mesh. This
                metric quantifies the cost of collapsing an edge, allowing the algorithm to prioritize the least
                impactful
                collapses. The quadric for a vertex is calculated using the sum of squared distances from the vertex to
                the
                planes of all faces adjacent to that vertex. Mathematically, the error quadric Q for a vertex v is given
                by:</p>
            <p><em>Q(v) = Σ (d<sub>plane</sub><sup>2</sup>)</em></p>
            <p>where <em>d<sub>plane</sub></em> is the distance from the vertex to a plane of an adjacent face.</p>

            <h4>Edge Collapse</h4>
            <p>The algorithm selects edges for collapse based on the combined error quadric of the edge's two vertices.
                The edge
                with the lowest error is chosen for collapse in each iteration, and its vertices are merged into a
                single
                vertex. The position of the new vertex is determined by minimizing the error quadric resulting from the
                collapse.</p>

            <h4>Preserving Mesh Integrity</h4>
            <p>While simplifying the mesh, QEM takes care to maintain the integrity and topological consistency of the
                mesh.
                This ensures that the simplified mesh remains a valid representation of the original geometry, albeit
                with fewer
                details.</p>

            <p>The effectiveness of QEM in reducing mesh complexity, while maintaining a high degree of fidelity to the
                original
                model, makes it invaluable for applications where real-time rendering performance is critical, such as
                in gaming
                and virtual reality.</p>
        </section>

        <br><br>
        <b>Implement Details </b>
        <p>
        <ul>
            <li><b>Quadric Matrices Computation:</b> For each vertex, a quadric matrix is computed based on the normals
                and
                distances of the
                adjacent faces. This matrix encapsulates the error introduced by moving the vertex along the surface.
            </li>

            <li><b>Error Metric for Edge Collapses:</b> The algorithm calculates an error metric for collapsing each
                edge.
                This
                metric is derived from the quadric matrices of the vertices at the ends of the edge, aiming to minimize
                the
                surface deviation.</li>

            <li><b>Priority Queue of Edges:</b> Edges are prioritized based on their error metric, with the least error
                edges
                being
                collapsed first. This ensures that the most geometrically significant features of the mesh are preserved
                longer.</li>

            <li><b>Edge Collapse:</b> The edge with the minimum error is collapsed by merging its two vertices into one,
                updating
                the mesh topology accordingly. The quadric matrices are also updated to reflect this change.</li>

            <li><b>Vertex and Face Updates:</b> After an edge collapse, the algorithm updates the mesh's vertices,
                faces,
                and
                their
                associations to ensure consistency.</li>

            <li><b>Target Vertex Count:</b> The process repeats until the mesh reaches the desired level of
                simplification,
                specified by a target vertex count.</li>

        </ul>
        </p>
        <br><br>
        <b>Results </b>
        <section>
            <p>The application of the Quadric Error Metrics (QEM) algorithm to the 3D mesh has yielded a series of
                simplified
                models, each representing a different level of detail. The QEM approach systematically reduces the
                complexity of
                the mesh while striving to maintain the overall shape and appearance of the original model. This is
                achieved
                by
                iteratively collapsing edges that contribute the least to the overall error metric, which is a measure
                of
                how
                much the surface deviates from the original.</p>

            <p>The following section shows 6 objects, the first one is the original, the second is the outcome of loop
                subdivision with 317952 faces and the remaining are the outcomes of QEM.
                The simplification process was performed with varying target face counts, resulting in four distinct
                levels
                of
                detail:</p>
            <ul>
                <li><strong>10,000 faces:</strong> This level maintains a high degree of detail, closely resembling the
                    original
                    model with only minor changes in the mesh complexity.</li>
                <li><strong>1,000 faces:</strong> A more pronounced simplification is observed, with smoother surfaces
                    and
                    less
                    definition in the finer features of the model.</li>
                <li><strong>500 faces:</strong> Further reduction in complexity leads to more noticeable changes in the
                    model's
                    geometry, yet the overall form remains identifiable.</li>
                <li><strong>200 faces:</strong> At this level, the model is significantly simplified, with an abstracted
                    form
                    where only the most basic features are retained.</li>
            </ul>

            <p>Throughout the simplification process, the QEM algorithm has successfully demonstrated its capability to
                produce
                a range of simplified meshes from the original high-resolution model. These meshes can be used in
                various
                applications where different levels of detail are required, such as in graphics rendering, where lower
                detail
                models may be preferred for real-time performance or distant viewing, while higher detail models are
                used
                for
                close-up shots or high-quality renders.</p>
        </section>


        </p>
        <div class="container-div">
            <div id="container2"></div>
            <div id="container3"></div>
            <div id="container4"></div>
            <div id="container5"></div>
            <div id="container6"></div>
            <div id="container7"></div>
        </div>
        <section>
            <h2>Extra Credits:</h2>
            <h3>1. Handling Corner Cases in Loop Subdivision</h3>
            <p>In addressing the corner cases within the Loop Subdivision algorithm, specific attention was given to the
                handling of boundary cases. This was achieved through a detailed process involving the separation of
                interior
                and boundary edges, calculation adjustments for odd and even vertices, and the proper integration of
                boundary
                conditions. The steps undertaken are outlined below:</p>
            <ol>
                <li><strong>Geometry Preparation:</strong> The initial geometry of the mesh was prepared by extracting
                    vertices
                    and faces, and subsequently, edges were identified and categorized into interior and boundary edges
                    based on
                    their occurrence within the mesh structure.</li>
                <li><strong>Odd Vertices Calculation:</strong> The positions of odd vertices were initially placed at
                    the
                    midpoint of each edge. For boundary edges, these positions were specifically adjusted to adhere to
                    the
                    boundary conditions, ensuring a smooth transition at the mesh borders.</li>
                <li><strong>Even Vertices Update:</strong> The positions of even vertices were recalculated with a
                    special
                    consideration for vertices at the boundary. This involved identifying boundary neighbors of each
                    vertex
                    and
                    adjusting the vertex position to maintain mesh integrity at the boundaries.</li>
                <li><strong>Mesh Reconstruction:</strong> With the updated positions of both odd and even vertices, the
                    mesh
                    was
                    reconstructed. This involved the integration of new vertices and faces, with particular adjustments
                    made
                    to
                    accommodate the boundary conditions, ensuring a seamless and accurate subdivision process.</li>
            </ol>
            <p>This comprehensive approach to handling boundary cases in loop subdivision not only enhances the accuracy
                of
                the
                subdivision process but also ensures the robustness of the algorithm in dealing with complex mesh
                topologies.
            </p>
        </section>


        <script type="module" src="js/script.js"></script>
</body>

</html>